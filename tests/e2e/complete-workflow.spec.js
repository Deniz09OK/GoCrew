// Tests Playwright complets pour GoCrew - Workflow utilisateur complet
const { test, expect } = require('@playwright/test');
const {
    generateTestData,
    signup,
    login,
    logout,
    navigateToSection,
    createAnnouncement,
    createCrew,
    createTask,
    editTask,
    deleteTask,
    deleteItem,
    waitForElement
} = require('../helpers');

test.describe('GoCrew - Workflow Utilisateur Complet', () => {
    let testData;

    test.beforeAll(() => {
        testData = generateTestData();
        console.log('üß™ Donn√©es de test g√©n√©r√©es:', testData);
    });

    test('Workflow complet utilisateur - Inscription √† D√©connexion', async ({ page }) => {
        console.log('üöÄ D√©but du workflow complet utilisateur');

        // ========== √âTAPE 1: INSCRIPTION ==========
        console.log('üìù √âtape 1: Inscription');
        await test.step('Inscription utilisateur', async () => {
            await signup(page, testData);
            
            // V√©rifier que l'inscription a r√©ussi
            const successMessage = page.locator('text=Inscription r√©ussie, text=Bienvenue, [data-testid="success-message"]');
            if (await successMessage.first().isVisible({ timeout: 5000 })) {
                await expect(successMessage.first()).toBeVisible();
            } else {
                console.log('‚ö†Ô∏è Message de succ√®s d\'inscription non trouv√©, continuons...');
            }
        });

        // ========== √âTAPE 2: CONNEXION ==========
        console.log('üîê √âtape 2: Connexion');
        await test.step('Connexion utilisateur', async () => {
            await login(page, testData);
            
            // V√©rifier qu'on est bien connect√© (URL ou √©l√©ment sp√©cifique)
            await expect(page).toHaveURL(/.*\/(home|dashboard)/);
            
            // V√©rifier la pr√©sence d'√©l√©ments de navigation
            const navigationElement = page.locator('nav, [data-testid="navigation"], .navbar, header');
            if (await navigationElement.first().isVisible({ timeout: 5000 })) {
                await expect(navigationElement.first()).toBeVisible();
            }
        });

        // ========== √âTAPE 3: CLIC BOUTON PROFIL ==========
        console.log('üë§ √âtape 3: Clic sur le bouton Profil');
        await test.step('Navigation vers le profil', async () => {
            // Chercher diff√©rents s√©lecteurs pour le bouton profil
            const profileSelectors = [
                'button:has-text("Profil")',
                'a[href="/profile"]',
                'a[href="/user-profile"]',
                '[data-testid="profile-button"]',
                '.profile-button',
                'img[alt*="Avatar"], img[alt*="Profile"]',
                'button:has(img[alt*="Avatar"])'
            ];

            let profileButton = null;
            for (const selector of profileSelectors) {
                profileButton = page.locator(selector);
                if (await profileButton.first().isVisible({ timeout: 2000 })) {
                    await profileButton.first().click();
                    break;
                }
            }

            // Si pas trouv√©, essayer de naviguer directement
            if (!profileButton || !(await profileButton.first().isVisible({ timeout: 1000 }))) {
                console.log('‚ö†Ô∏è Bouton profil non trouv√©, navigation directe...');
                await page.goto('/profile');
            }

            await page.waitForTimeout(2000);
            console.log('‚úÖ Navigation vers profil effectu√©e');
        });

        // ========== √âTAPE 4: CLIC BOUTON ACCUEIL ==========
        console.log('üè† √âtape 4: Clic sur le bouton Accueil');
        await test.step('Navigation vers l\'accueil', async () => {
            const homeSelectors = [
                'button:has-text("Accueil")',
                'a:has-text("Accueil")',
                'a[href="/home"]',
                'a[href="/dashboard"]',
                '[data-testid="home-button"]',
                '.home-button'
            ];

            let homeButton = null;
            for (const selector of homeSelectors) {
                homeButton = page.locator(selector);
                if (await homeButton.first().isVisible({ timeout: 2000 })) {
                    await homeButton.first().click();
                    break;
                }
            }

            if (!homeButton || !(await homeButton.first().isVisible({ timeout: 1000 }))) {
                console.log('‚ö†Ô∏è Bouton accueil non trouv√©, navigation directe...');
                await page.goto('/home');
            }

            await page.waitForTimeout(2000);
            console.log('‚úÖ Navigation vers accueil effectu√©e');
        });

        // ========== √âTAPE 5: CLIC BOUTON ANNONCES ==========
        console.log('üì¢ √âtape 5: Clic sur le bouton Annonces');
        await test.step('Navigation vers les annonces', async () => {
            const announcementSelectors = [
                'button:has-text("Annonce")',
                'a:has-text("Annonces")',
                'a[href="/announcements"]',
                '[data-testid="announcements-button"]',
                '.announcements-button'
            ];

            let announcementButton = null;
            for (const selector of announcementSelectors) {
                announcementButton = page.locator(selector);
                if (await announcementButton.first().isVisible({ timeout: 2000 })) {
                    await announcementButton.first().click();
                    break;
                }
            }

            if (!announcementButton || !(await announcementButton.first().isVisible({ timeout: 1000 }))) {
                console.log('‚ö†Ô∏è Bouton annonces non trouv√©, navigation directe...');
                await page.goto('/announcements');
            }

            await page.waitForLoadState('networkidle');
            console.log('‚úÖ Navigation vers annonces effectu√©e');
        });

        // ========== √âTAPE 6: CR√âER UNE ANNONCE ==========
        console.log('‚ûï √âtape 6: Cr√©ation d\'une annonce');
        await test.step('Cr√©er une annonce', async () => {
            await createAnnouncement(page, testData);
            
            // V√©rifier que l'annonce a √©t√© cr√©√©e
            const announcementCard = page.locator(`text=${testData.announcementTitle}`);
            await expect(announcementCard.first()).toBeVisible({ timeout: 10000 });
            console.log('‚úÖ Annonce cr√©√©e avec succ√®s');
        });

        // ========== √âTAPE 7: OUVRIR LE KANBAN DE L'ANNONCE ==========
        console.log('üìã √âtape 7: Ouverture du kanban de l\'annonce');
        await test.step('Ouvrir kanban de l\'annonce', async () => {
            // Cliquer sur l'annonce cr√©√©e - elle devrait √™tre visible dans la grille
            await page.waitForTimeout(2000); // Attendre que la grille soit mise √† jour
            
            // Chercher la carte d'annonce nouvellement cr√©√©e
            const announcementSelectors = [
                `.cursor-pointer:has-text("${testData.announcementTitle}")`,
                `[class*="bg-white"]:has-text("${testData.announcementTitle}")`,
                `[class*="card"]:has-text("${testData.announcementTitle}")`,
                `text=${testData.announcementTitle}`
            ];
            
            let announcementCard = null;
            for (const selector of announcementSelectors) {
                try {
                    announcementCard = page.locator(selector).first();
                    if (await announcementCard.isVisible({ timeout: 3000 })) {
                        console.log(`   ‚úÖ Carte d'annonce trouv√©e avec: ${selector}`);
                        break;
                    }
                } catch (error) {
                    console.log(`   ‚ùå Carte non trouv√©e avec: ${selector}`);
                    continue;
                }
            }
            
            if (!announcementCard) {
                throw new Error('Carte d\'annonce non trouv√©e apr√®s cr√©ation');
            }
            
            // Cliquer sur la carte d'annonce
            await announcementCard.click();
            console.log('‚úÖ Clic sur la carte d\'annonce effectu√©');
            
            // Attendre que le modal Kanban s'ouvre
            // D'apr√®s KanbanBoard.jsx, c'est un modal avec classe 'fixed inset-0'
            const kanbanModalSelectors = [
                '.fixed.inset-0',
                '[role="dialog"]',
                '.z-50', // Le KanbanBoard a z-50 dans son modal
                '.bg-black.bg-opacity-50' // L'overlay du modal
            ];
            
            let kanbanModal = null;
            for (const selector of kanbanModalSelectors) {
                try {
                    kanbanModal = await page.waitForSelector(selector, { timeout: 8000 });
                    if (kanbanModal) {
                        console.log(`   ‚úÖ Modal Kanban trouv√© avec: ${selector}`);
                        break;
                    }
                } catch (error) {
                    console.log(`   ‚ùå Modal non trouv√© avec: ${selector}`);
                    continue;
                }
            }
            
            if (!kanbanModal) {
                console.log('‚ö†Ô∏è Modal Kanban non trouv√©, tentative de recherche des colonnes directement...');
                
                // Si le modal n'est pas trouv√©, chercher les colonnes Kanban directement
                const columnSelectors = [
                    'text=todo',
                    'text=doing', 
                    'text=done',
                    '.kanban-column',
                    '[class*="column"]'
                ];
                
                for (const selector of columnSelectors) {
                    try {
                        const column = await page.waitForSelector(selector, { timeout: 5000 });
                        if (column) {
                            console.log(`   ‚úÖ Colonne Kanban trouv√©e avec: ${selector}`);
                            break;
                        }
                    } catch (error) {
                        console.log(`   ‚ùå Colonne non trouv√©e avec: ${selector}`);
                        continue;
                    }
                }
            }
            
            console.log('‚úÖ Kanban de l\'annonce ouvert');
        });

        // ========== √âTAPE 8: CR√âER UNE CARD DANS L'ANNONCE ==========
        console.log('üìù √âtape 8: Cr√©ation d\'une card dans l\'annonce');
        const announcementTaskTitle = `${testData.taskTitle} Annonce`;
        await test.step('Cr√©er une t√¢che dans l\'annonce', async () => {
            await createTask(page, announcementTaskTitle);
            
            // V√©rifier que la t√¢che a √©t√© cr√©√©e
            const taskCard = page.locator(`text=${announcementTaskTitle}`);
            await expect(taskCard.first()).toBeVisible({ timeout: 5000 });
            console.log('‚úÖ T√¢che cr√©√©e dans l\'annonce');
        });

        // ========== √âTAPE 9: MODIFIER LA CARD ==========
        console.log('‚úèÔ∏è √âtape 9: Modification de la card');
        const modifiedAnnouncementTaskTitle = `${announcementTaskTitle} - Modifi√©e`;
        await test.step('Modifier la t√¢che de l\'annonce', async () => {
            await editTask(page, announcementTaskTitle, modifiedAnnouncementTaskTitle);
            
            // V√©rifier que la t√¢che a √©t√© modifi√©e
            const modifiedTaskCard = page.locator(`text=${modifiedAnnouncementTaskTitle}`);
            await expect(modifiedTaskCard.first()).toBeVisible({ timeout: 5000 });
            console.log('‚úÖ T√¢che modifi√©e dans l\'annonce');
        });

        // ========== √âTAPE 10: SUPPRIMER LA CARD ==========
        console.log('üóëÔ∏è √âtape 10: Suppression de la card');
        await test.step('Supprimer la t√¢che de l\'annonce', async () => {
            await deleteTask(page, modifiedAnnouncementTaskTitle);
            
            // V√©rifier que la t√¢che a √©t√© supprim√©e
            const deletedTaskCard = page.locator(`text=${modifiedAnnouncementTaskTitle}`);
            await expect(deletedTaskCard).toHaveCount(0);
            console.log('‚úÖ T√¢che supprim√©e de l\'annonce');
        });

        // ========== √âTAPE 11: SUPPRIMER L'ANNONCE ==========
        console.log('üóëÔ∏è √âtape 11: Suppression de l\'annonce');
        await test.step('Supprimer l\'annonce', async () => {
            // Fermer le modal Kanban d'abord
            console.log('üîê Fermeture du modal Kanban...');
            
            const closeSelectors = [
                'button:has(svg)', // Bouton avec ic√¥ne SVG (X)
                'button[title*="Fermer"]',
                'button:has-text("‚úï")',
                'button:has-text("√ó")', 
                '.hover\\:bg-gray-100', // Style du bouton de fermeture dans le header
                '[class*="text-gray-400"]:has(svg)' // Bouton gris avec ic√¥ne
            ];
            
            let modalClosed = false;
            for (const selector of closeSelectors) {
                try {
                    const closeButton = page.locator(selector).first();
                    if (await closeButton.isVisible({ timeout: 3000 })) {
                        await closeButton.click();
                        console.log(`   ‚úÖ Modal ferm√© avec: ${selector}`);
                        modalClosed = true;
                        break;
                    }
                } catch (error) {
                    console.log(`   ‚ùå √âchec fermeture: ${selector}`);
                    continue;
                }
            }
            
            if (!modalClosed) {
                console.log('‚ö†Ô∏è Bouton de fermeture non trouv√©, tentative ESC...');
                await page.keyboard.press('Escape');
            }
            
            // Attendre que le modal se ferme
            await page.waitForTimeout(2000);
            
            // V√©rifier que nous sommes bien sur la page des annonces
            if (!page.url().includes('/announcements')) {
                console.log('üìç Navigation vers les annonces...');
                await navigateToSection(page, 'announcements');
            }
            
            await deleteItem(page, testData.announcementTitle, 'announcement');
            
            // V√©rifier que l'annonce a √©t√© supprim√©e
            const deletedAnnouncementCard = page.locator(`text=${testData.announcementTitle}`);
            await expect(deletedAnnouncementCard).toHaveCount(0);
            console.log('‚úÖ Annonce supprim√©e');
        });

        // ========== √âTAPE 12: ALLER DANS VOYAGES ==========
        console.log('‚úàÔ∏è √âtape 12: Navigation vers Voyages');
        await test.step('Naviguer vers la section Voyages', async () => {
            const tripsSelectors = [
                'a:has-text("Voyages")',
                'a[href="/trips"]',
                'button:has-text("Voyages")',
                '[data-testid="trips-button"]',
                '.trips-button'
            ];

            let tripsButton = null;
            for (const selector of tripsSelectors) {
                tripsButton = page.locator(selector);
                if (await tripsButton.first().isVisible({ timeout: 2000 })) {
                    await tripsButton.first().click();
                    break;
                }
            }

            if (!tripsButton || !(await tripsButton.first().isVisible({ timeout: 1000 }))) {
                console.log('‚ö†Ô∏è Bouton voyages non trouv√©, navigation directe...');
                await page.goto('/trips');
            }

            await page.waitForLoadState('networkidle');
            console.log('‚úÖ Navigation vers voyages effectu√©e');
        });

        // ========== √âTAPE 13: CR√âER UN CREW ==========
        console.log('üë• √âtape 13: Cr√©ation d\'un crew');
        await test.step('Cr√©er un crew', async () => {
            await createCrew(page, testData);
            
            // V√©rifier que le crew a √©t√© cr√©√©
            const crewCard = page.locator(`text=${testData.tripName}`);
            await expect(crewCard.first()).toBeVisible({ timeout: 10000 });
            console.log('‚úÖ Crew cr√©√© avec succ√®s');
        });

        // ========== √âTAPE 14: OUVRIR LE KANBAN DU CREW ==========
        console.log('üìã √âtape 14: Ouverture du kanban du crew');
        await test.step('Ouvrir kanban du crew', async () => {
            // Cliquer sur le crew cr√©√©
            const crewCard = page.locator(`text=${testData.tripName}`).first();
            await crewCard.click();
            
            // Attendre que le kanban s'ouvre
            await waitForElement(page, '[data-testid="kanban-board"], .kanban, [class*="kanban"]');
            console.log('‚úÖ Kanban du crew ouvert');
        });

        // ========== √âTAPE 15: CR√âER UNE CARD DANS LE CREW ==========
        console.log('üìù √âtape 15: Cr√©ation d\'une card dans le crew');
        const crewTaskTitle = `${testData.taskTitle} Crew`;
        await test.step('Cr√©er une t√¢che dans le crew', async () => {
            await createTask(page, crewTaskTitle);
            
            // V√©rifier que la t√¢che a √©t√© cr√©√©e
            const taskCard = page.locator(`text=${crewTaskTitle}`);
            await expect(taskCard.first()).toBeVisible({ timeout: 5000 });
            console.log('‚úÖ T√¢che cr√©√©e dans le crew');
        });

        // ========== √âTAPE 16: MODIFIER LA CARD DU CREW ==========
        console.log('‚úèÔ∏è √âtape 16: Modification de la card du crew');
        const modifiedCrewTaskTitle = `${crewTaskTitle} - Modifi√©e`;
        await test.step('Modifier la t√¢che du crew', async () => {
            await editTask(page, crewTaskTitle, modifiedCrewTaskTitle);
            
            // V√©rifier que la t√¢che a √©t√© modifi√©e
            const modifiedTaskCard = page.locator(`text=${modifiedCrewTaskTitle}`);
            await expect(modifiedTaskCard.first()).toBeVisible({ timeout: 5000 });
            console.log('‚úÖ T√¢che modifi√©e dans le crew');
        });

        // ========== √âTAPE 17: SUPPRIMER LA CARD DU CREW ==========
        console.log('üóëÔ∏è √âtape 17: Suppression de la card du crew');
        await test.step('Supprimer la t√¢che du crew', async () => {
            await deleteTask(page, modifiedCrewTaskTitle);
            
            // V√©rifier que la t√¢che a √©t√© supprim√©e
            const deletedTaskCard = page.locator(`text=${modifiedCrewTaskTitle}`);
            await expect(deletedTaskCard).toHaveCount(0);
            console.log('‚úÖ T√¢che supprim√©e du crew');
        });

        // ========== √âTAPE 18: SUPPRIMER LE CREW ==========
        console.log('üóëÔ∏è √âtape 18: Suppression du crew');
        await test.step('Supprimer le crew', async () => {
            // Fermer le kanban d'abord
            const closeButton = page.locator('button:has-text("‚úï"), button:has-text("Fermer"), [data-testid="close-button"]');
            if (await closeButton.first().isVisible({ timeout: 3000 })) {
                await closeButton.first().click();
                await page.waitForTimeout(1000);
            }
            
            // Revenir √† la page des voyages si n√©cessaire
            if (!page.url().includes('/trips')) {
                await navigateToSection(page, 'trips');
            }
            
            await deleteItem(page, testData.tripName, 'crew');
            
            // V√©rifier que le crew a √©t√© supprim√©
            const deletedCrewCard = page.locator(`text=${testData.tripName}`);
            await expect(deletedCrewCard).toHaveCount(0);
            console.log('‚úÖ Crew supprim√©');
        });

        // ========== √âTAPE 19: D√âCONNEXION ==========
        console.log('üö™ √âtape 19: D√©connexion');
        await test.step('D√©connexion utilisateur', async () => {
            await logout(page);
            
            // V√©rifier qu'on est bien d√©connect√©
            await expect(page).toHaveURL(/.*\/login/);
            console.log('‚úÖ D√©connexion effectu√©e avec succ√®s');
        });

        console.log('üéâ Workflow complet termin√© avec succ√®s !');
    });

    test.afterEach(async ({ page }) => {
        // Nettoyer les donn√©es de test si n√©cessaire
        console.log('üßπ Nettoyage post-test...');
    });
});
